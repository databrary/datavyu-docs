===============
Script Examples
===============

-  `Example-Template.opf <Example-Template.opf>`__

Lets walk through building a script. For the sake of this example, we'll
be using the simple template in the link above. 

It contains an ``ID`` variable with some basic information such as
subject number, testdate, birthdate, and condition. Then there is a
``trial`` variable that has two arguments: ``trialnum`` and ``outcome``.
``trial`` has no cells in it yet. We're going to be modifying this file,
so download it and load open it with Datavyu!

Load Datavyu Variables
----------------------

Most scripts begin by loading the desired variables. To do this, use the
function :function:`getVariable`. :function:`getVariable` takes one parameter: the name
of the variable in Datavyu, and returns :function:`getVariable` returns the Ruby
representation of the variable, which you work with. Finally, save any
changes to that variable back to the database.

.. code-block:: ruby

   require 'Datavyu_API.rb'
   begin
      # Assign the Datavyu variable "trial" data to a new Ruby variable called trial.
     
      trial = getVariable("trial")
   end

The left side of this equation is the name of the Ruby variable,
the "trial" in the parentheses is the argument passed to
:function:`getVariable` (the name of the Datavyu variable).

.. image:: /img/variable-assignment-mapping.png

.. _api-add-arguments:

Add Arguments to a Variable
---------------------------

.. following paragraph makes no sense

Now we probably want to do something with that variable that we just
loaded. Lets start by doing something simple, like adding arguments to a
variable. We use a method called ``add_arg`` to do this. As hopefully you
remember from your Ruby tutorial, methods are functions that are part of
classes. In this case, ``add_arg`` is a method of the ``RVariable``
class. The basic idea is that a method "belongs" to an instance of a
class, so using the above example, the ``RVariable`` ``trial`` "owns" a function
called ``add_arg`` that will add an argument to its cells.

This somewhat confusing thing is probably most easily seen in an
example:

#. Assign the Datavyu variable "trial" to a new Ruby variable called ``trial``

   .. code-block:: ruby
   
      trial = getVariable("trial")

#. Add an argument to ``trial`` using ``add_arg``. In this example,
   we'll add a study variable argument called "unit" to the ``trial``
   variable. The "unit" argument might represent the unit of measure used
   during an experiment, for instance.
   
   .. code-block:: ruby
   
      trial.add_arg("unit")

#. Write the changes back to the Datavyu database:

   .. code-block:: ruby
   
      setVariable(trial)

Put together, the script should resemble the following:

.. code-block:: ruby

   require 'Datavyu_API.rb'
   begin
      # Assign the Datavyu variable "trial" data to a new Ruby variable called trial.
      trial = getVariable("trial")

      # Add "unit" argument        
      trial.add_arg("unit")

      # Now we have to write back our changes
      setVariable(trial)
   end

.. _api-add-cells:

Add Cells to a Variable
-----------------------

Now that Lets do something a little more interesting than just adding an
argument. Lets add some cells to a column. Say that we know that a new
trial starts every minute from 0 to 4 minutes, yielding 5 trials. We
want to make a new blank cell for each of these trials with the onset
set to that time, so it is easy for the coder to code them.

.. code-block:: ruby

    require 'Datavyu_API.rb'
    begin
        # Load the Datavyu variable "trial" into Ruby variable called trial.
        trial = getVariable("trial")

        # We need to loop 5 times from 0 to 4
        for i in 0..4
            # Calculate the onset time that we want to set
            # Remember that all times in Datavyu are milliseconds
            time = i * 1000 * 60

            # Create the new cell.
            cell = trial.make_new_cell()

            # Now change the onset of the cell we just created
            cell.change_arg("onset", time)
        end

        # Now that the loop is finished (we're outside of the end), write
        # it back to the database
        setVariable(trial)
    end

.. _api-add-new-variable:

Adding a new variable
---------------------

Adding a new variable is also pretty easy, and is done with the
[[createVariable]] function. The first parameter of createVariable is
the name of the new column, and all subsequent parameters are arguments
to add to the variable. For example, if we wanted to make a variable
called step with three arguments called foot (for the left or right
foot), ht (for heel or toe), and direction (forward or backward step),
we would do the following:

.. code-block:: ruby

    require 'Datavyu_API.rb'
    begin
        # Create the new variable with three arguments
        step = createVariable("step", "foot", "ht", "direction")

        # Now write it back to the database as a variable without any cells
        setVariable(step)
    end

.. _api-check-for-typos:

Check for Typos
---------------

Another common use for scripts is to do a quick check for any typos that
a coder made. This is primarily used to catch typographic errors where a coder entered an invalid code, such as 
an "h" when only "j" and "k" are valid codes,
or hit more than one key: "hj" instead of "j" or "k", for example. These kinds
of scripts should be run immediately after each coding pass so that
errors are caught early on and recoded. 

Datavyu API provides the :function:`checkValidCodes` function to check
for coder errors. :function:`checkValidCodes` requires at least three
parameters: the name of the variable to it will verify, and then at
least one :term:`key-value pair`. Key-value pairs consist of the "key",
the name of a Datavyu argument, and a "value", which is an array of
valid codes for that argument.

:function:`checkValidCodes` checks each argument (key) against its list of
valid codes (the values). 

The following example checks the variable ``step`` against its codes:

.. code-block:: ruby

    require 'Datavyu_API.rb'
    begin
      # Check for typos. Notice the square brackets. These denote arrays. So the basic format is:
      # "variable", argumentname, [validarg1, validarg2, validarg3], argument2, [ ... ], 
    
      checkValidCodes("step", "foot", ["l", "r"], "ht", ["h", "t"], "direction", ["f","b"])
    end

The same verification can be done more clearly by first assigning the
valid codes to variables, as in the next example:

.. code-block:: ruby

   require 'Datavyu_API.rb'
   begin
     # Store each of the valid code arrays into a variable first so it is easier to read
    
     footCodes = ["l", "r"]
     htCodes = ["h", "t"]
     directionCodes = ["f", "b"]

     # Check for typos, replacing the code arrays with your new variables:
    
     checkValidCodes("step", "foot", footCodes, "ht", htCodes, "direction", directionCodes)
   end

.. _api-reliability:
.. _api-make-reliability-variable:

Make a Reliability Variable
-----------------------------

Creating a reliability column is another very common task. The idea is
that we want to take some subset of cells from an already coded column
and create blank or semi-blank cells in a new column for a reliability
coder to code, to make sure that two people can see the same things in
the data. To do this, we use the function [[makeReliability]].

The first parameter is the variable that we want to create a reliability
column **from**, our primary variable. The second is what what we want
to call our reliability variable. The third parameter how many cells we
want to skip. For example, a value of 2 means "every other cell", a
value of 3 is "every third cell", and so on. 1 means copy all of the
cells, and 0 means make a blank column.

The rest are the arguments that we want to copy over from the primary
variable that we don't want the reliability coder to have to code. This
could be things such as the trial number or other non-essential
information. It is also very helpful to copy over the onset time of a
trial so the reliability coder can just to that point in the video.
Given our trial variable above, we want to make a new variable called
"rel.trial" with blank offset and outcome arguments, but onset and
trialnum should be carried over (we don't care about the reliability
coder coding those). We do that like this:

.. code-block:: ruby

    require 'Datavyu_API.rb'
    begin
        # Make a new reliability variable that makes a new semi-blank cell for every other primary
        # cell. Copy over the onset and the trialnum though
        makeReliability("trial", "rel.trial", 2, "onset", "trialnum")
    end

Note that we do **not** have to write the variable back to the database.
The [[makeReliability]] function will take care of that for us
automatically. This is the only function that this is true for.

.. _api-check-reliability:

Checking reliability
--------------------

Once the reliability variable is coded, we want to compare the cells in
the reliability column to those in the primary column. An easy way to do
this is to use the [[checkReliability]] function. This function
simplifies the process by taking the primary and reliability variables
and comparing the cells, giving you some quick at-a-glance statistics
about the reliability (such as percent agreement). The function takes
four parameters. The first is the primary variable, the second is the
reliability variable, the third is the binding argument (more on this in
a second), and the fourth is an optional file to write the output to.

The third argument is the tricky one. In order for the function to know
which cells to compare, it needs to have some parameter that is unique
to each combination of primary and reliability cells. An example of this
would be a trial number that is coded into each cell: that way even if
we only did every 3rd cell in the reliability column (or some randomized
subset), then we know that the primary cell with a certain trial number
matches the reliability cell with that same trial number, and we can
compare the codes between those two. It is best to have had this
variable carried over when making the reliability column with
[[makeReliability]]. Any unique argument will work though, including
onsets.

The fourth argument is an optional file to print to. Pass the string
representing the location of the file you'd like to write to. See how to
do this in the example below:

.. code-block:: ruby

    require 'Datavyu_API.rb'
    begin
        # We have two variables that we want to compare, trial and rel.trial. They match on an argument called trialnumber.
        # We want to dump the results to a file on the desktop.

        # As before, File.expand_path with unfold the ~ in the filename to be our users' home directory
        dump_file = File.expand_path("~/Desktop/relcheck.txt")
        checkReliability("trial", "rel.trial", "trialnum", dump_file)
    end
